<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_mask_main</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables.

 // Init. flag:
    initialized     = false;      // Checks if the player has been initialized.
    
 // Character flag.
    player_index    = global.player_id; // Who do we play as?
    player_type     = IS_PLAYER;        // Is a Player or AI?
  
 // Horizontal movement:
    x_speed         = 0;        // The current horizontal speed.
    x_speed_top     = 6;        // Horizontal top speed while on flat ground.
    x_speed_max     = 16;       // Fastest the player can move.
    g_speed         = 0;        // Stores the ground speed.
    x_acceleration  = 0.046875; // Horizontal acceleration on ground.
    x_deceleration  = 0.5;      // Horizontal deceleration on ground.
    x_slope_factor  = 0.125;    // Rate at which the player slows down on slopes.
    x_air_accel     = 0.09375;  // Acceleration value in the air.
    x_temp_accel    = 0;        // Stores temporal acceleration value. 
    x_temp_decel    = 0;        // Stores temporal deceleration value.
    x_temp_friction = 0;        // Stores temporal friction value.
    x_limit         = false;    // Limits the horizontal speed.
    x_allow         = 0;        // Allows horizontal movement.

 // Vertical movement:
    y_speed         = 0;        // The current vertical speed.
    y_speed_max     = 16;       // Fastest the player can fall.
    y_acceleration  = 0.21875;  // Force of gravity applied to the player.
    y_accel_common  = 0.21875;  // Store original gravity value in case we change it ingame.
    y_conversion    = 1;        // Speed conversion when landing.
    y_limit         = true;     // Limits the vertical speed.
    y_allow         = 0;        // Allows vertical movement.

 // Samples.
    x_sample        = 13;       // Pixel limit to divide horizontal movement.
    y_sample        = 13;       // Pixel limit to divide vertical movement.
          
 // Terrain:
    ground          = 0;        // Checks if the player has/is grounded.
    angle           = 0;        // Returns the angle of the player.
    angle_round     = 0;        // Returns the angle of the player, rounded.
    angle_relative  = 0;        // Returns the angle, relative to gravity values.
    angle_hold      = 0;        // Used to smoothen angle values.
    collision_layer = 0;        // Returns the layers the player is on.
    floor_mode      = 0;        // Returns the floor mode.
    x_beforepush    = 0;        // X Position before player was pushed (not used)      
    y_beforepush    = 0;        // Y Position before player was pushed (not used)
    platform_check  = 0;        // Checks if the player has landed on platforms.
    platform_frames = 30;       // Used to reset the platform check.
    
 // Flags:
    state           = 1;        // Players current state.
    input_alarm     = 0;        // Input alarm. (Used for slopes9
    input_alarm_dir = 0;        // Which direction we're locking.
    input_lock_l    = 0;        // Locks left input.
    input_lock_r    = 0;        // Locks right input.
    input_lock_s    = 0;        // locks input after using a horizontal spring.
    launch_lock     = 0;        // Disables horizontal input.
    lock_timer      = 0;        // How long input is locked. Used on springs.
    tunnel_lock     = 0;        // Locks the player when inside a tunnel.
    timer_up        = 0;        // Timer for looking up.
    timer_down      = 0;        // Timer for crouching.
    allow_look      = 1;        // Allow crouching/looking up.
    shield          = 0;        // Players current shield.
    shield_obj      = noone;    // Players shield object.
    shield_state    = 0;        // Players shield state.
    shield_usable   = 0         // Is the shield usable?
    invincibility   = 0;        // Is the player invulnerable to hazards? 0 = No, 1 - After getting Hit, 2 - Invincibility Shield or Super Form.
    invincibility_timer = 0;    // How long invincibility lasts.
    physic_mode     = 0;        // Checks the current physic mode. (0 = Default, 1 = Underwater)
    speedshoe       = 0;        // Are we wearing speed shoes?
    speedshoe_timer = 0;        // How long speed shoes last.
    previous_x      = 0;        // Gets the previous x position.
    previous_y      = 0;        // Gets the previous y position. 
    loop_direction  = 0;        // Keeps track in which direction we're going through a loop. Used for AI.
        
 // Terrain flags:
    platform_id     = noone;    // Returns the id of the platform we're on.
    swing_id        = noone;    // Returns the id of the swing we're on.
 
 // Underwater:
    drown_timer     = 1800;     // How long it takes (in frames) for the character to drown.
    drown_counter   = noone;    // The number count down above the character while about to drown.
    bubble_timer    = 0;        // How long the character is stuck in the breathing state after touching a bubble.
    breath_timer    = 40;       // Needed for creating bubbles after we drowned.
    has_drowned     = false;    // Checks if the Character has drowned.
    
 // States:
    jump_strength     = -6.5    // Players jump strength.
    jump_release      = -4;     // Minimum strength the player can jump.
    jump_completed    = false;  // Checks if the player has completed his jump.
    jump_lock         = 0;      // Is the jump locked? (Means the direction cannot be altered while jumping)
    
    spindash_strength = 0;      // Current strength of the spindash.
    spindash_pitch    = 0;      // Used to change the spindash sound pitch.
    
    roll_deceleration = 0.125;     // Rolling deceleration.
    roll_friction     = 0.0234375  // Friction while rolling.
    roll_decel_up     = 0.078125;  // Deceleration while rolling up slopes.
    roll_decel_down   = 0.3125;    // Deceleration while rolling down slopes.
    
    skid_direction    = 0;         // Direction you're skiddin towards.
    
    grab_timer        = 0;         // Grab timer, prevents us from grabbing onto something as soon as we try to let go.
    grab_type         = 0;         // Grab type, see the grab scripts for more.
    grab_distance     = 0;         // How far we can travel.
    grab_moving       = 0;         // Checks if we're moving-
    grab_id           = 0;
    grab_x            = 0;
    grab_y            = 0;
    
    push_timer        = 0;         // Used to trigger pushing state.
    push_timer_max    = 3;
    
    death_timer       = -5;       // See death script in the step event.
 
 // Animation / Sprite.
    animation_init();
    
 // Done initializing.
    initialized = true;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stage Specifics.

// Bonus Stage
mynumber = -1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character specific.

 // Sonic:
    allow_dropdash = true;                   // If true, we allow the player to use the dropdash.
    dropdash_flag  = 0;                      // Returns the dropdash flag. (0 = Null, 1 = Charging, 2 = Ready)
    dropdash_timer = 20;                     // Frames it takes to charge dropdash.
    dropdash_speed = 0;                      // Speed of the dropdash.
  
 // Tails: 
    tails_flight_timer    = 0;               // How long we've been flying.
    tails_flight_duration = 480;             // How long we can fly.
    
    tails_tail_sprite     = noone;           // Sprite for Tails tail.
    tails_tail_frame      = 0;               // Current tail frame.
    tails_tail_speed      = 0;               // Animation speed for the tail. 
    tails_tail_x          = 0;               // X Position for the tail.
    tails_tail_y          = 0;               // Y Position for the tail.
    tails_tail_angle      = 1;               // Angle of the tail. 
    tails_tail_direction  = 1;               // Direction of the tail.
    
 // Knuckles:
    glide_top_speed    = 24;                 // Fastest Knuckles can move horizontally while gliding.
    glide_gravity      = 0.125;              // The gravity used while gliding.
    glide_crouch_timer = 25;                 // How long knuckles stays in his crouched state (after a drop)
    glide_turn_s       = 0;                  // Special variable for turning knuckles sprite.
    glide_turn_a       = 0;                  // ^^ 
    climb_ox           = 0;                  // Position that returns the x position when grabbing. If it increases or decreases, we stop climbing.
    climb_speed        = 1;                  // How fast Knuckles can climb up a wall.
    climb_frame_timer  = 6;                  // Advances the climbing frame when it reaches 0.
    is_ledge_grabbing  = 0;                  // Returns if we're ledge climbing.     
     
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inputs keys.
 
    input_up               = false;
    input_down             = false;
    input_right            = false;
    input_left             = false;
    input_action           = false;
    input_special          = false;
    
    input_up_pressed       = false;
    input_down_pressed     = false;
    input_right_pressed    = false;
    input_left_pressed     = false;
    input_action_pressed   = false;
    input_special_pressed  = false;    
    
    input_up_released      = false;
    input_down_released    = false;
    input_right_released   = false;
    input_left_released    = false;
    input_action_released  = false;
    input_special_released = false;    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera.

    camera = instance_create(x, y, obj_camera);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Checkpoint respawn.
 
    if(global.checkpoint_x != -1)
    {
       x                = global.checkpoint_x;
       y                = global.checkpoint_y;
       global.game_time = global.checkpoint_t;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animations.

 // Exit if not initialized or death.
    if(initialized = false) exit;
     
 // Setup core system:
    animation_core();
    
 // Apply correct tail parts. 
    if(player_index == CHAR_TAILS)
    {
       animation_tail_setup();
    }
        
 // Frame counts:
    if(player_index == CHAR_SONIC)
    {
       switch (animation)
       {
          case   ("idle"):       { if(animation_frame_count &lt; 288) {animation_frame_count += 1} break; }
          case   ("idle bored"): { animation_frame_count = 288; break; }
          case   ("skid"):       { animation_frame_count += 1;  break; }
          case   ("skid turn"):  { animation_frame_count += 1;  break; }
          default:               { animation_frame_count = 0;   break; } 
       }
    }
    else if(player_index == CHAR_TAILS || player_index == CHAR_KNUCKLES)
    {
            switch (animation)
            {
                case   ("idle"): 
                case   ("idle bored"):   { if(animation_frame_count &lt; 360) {animation_frame_count += 1}; if((animation_frame_count mod 120) == 0) { animation = "idle bored" } break; }     
                case   ("idle bored 2"): { animation_frame_count = 360; break; }                
                case   ("skid"):         { animation_frame_count  += 1;   break; }
                case   ("skid turn"):    { animation_frame_count  += 1;   break; }
                case   ("slide"):        { animation_frame_count  += 1;   break; }                
                default:                 { animation_frame_count  = 0;    break; } 
       }    
    }

    // Default Animations
       if(state == STATE_DEFAULT)
       {              
          // Change from idle to ground if in mid air
              if (!ground &amp;&amp; animation = "idle")
              {
              animation = "walk";
              }
               
         
       }  
        
 // Check states to apply animations:
    if(ground)
    {   
          // Default Animations
              if (state == STATE_DEFAULT)
              {         
                    // Idle
                     if(player_index == CHAR_SONIC)
                     {
                        if(x_speed == 0 &amp;&amp; animation_frame_count != 288 &amp;&amp; animation != "idle")
                        {
                           animation = 'idle';
                        }else if(x_speed == 0 &amp;&amp; animation_frame_count &gt;= 288 &amp;&amp; animation != "idle bored"){
                           animation = "idle bored";
                        }
                     }
                     if(player_index == CHAR_TAILS || player_index == CHAR_KNUCKLES)
                     {
                        if(x_speed == 0 &amp;&amp; animation_frame_count != 360 &amp;&amp; animation != "idle")
                        {
                           if(animation != "idle bored")
                           {
                              animation = 'idle';
                           }
                        }else if(x_speed == 0 &amp;&amp; animation_frame_count &gt;= 360 &amp;&amp; animation != "idle bored 2"){
                           animation = "idle bored 2";
                        }
                     }           
                             
                  // Walking:
                     if(x_speed != 0 &amp;&amp; abs(x_speed) &lt; 5.50 &amp;&amp; animation != "walk")
                     {
                        animation = "walk";
                     }
                     
                  // Run:
                     if(abs(x_speed) &gt;= 5.50 &amp;&amp; animation != "run")
                     {
                        animation = "run";
                     } 
            
            }
        
       // Looking up:
          if(state == STATE_LOOKUP &amp;&amp; animation != "look up")
          {
             animation = "look up";
          }        
               
       // Crouch:
          if(state == STATE_CROUCH &amp;&amp; animation != "crouch")
          {
             animation = "crouch";
          }
          
       // Spindash:
          if(state == STATE_SPINDASH &amp;&amp; animation != "spindash")
          {
             animation = "spindash";
          }    
          
       // Rolling:
          if(state == STATE_ROLL &amp;&amp; animation != "roll")
          {
             animation = "roll";
          }      
          
       // Push:
          if(state == STATE_PUSH &amp;&amp; animation != "push")
          {
             animation = "push";
          }      
              
       // Slide:
          if(state == STATE_SLIDE &amp;&amp; animation != "slide")
          {
             animation = "slide";
          }                                               
    }
    if not(ground)
    {
           // Jumping:
              if(state == STATE_JUMP || state == STATE_ROLL &amp;&amp; animation != "roll")
              { 
                 animation = "roll";
              }
              
           // Dropdash.
              if(dropdash_flag == 2)
              {
                 animation = "dropdash"
              }
           
           // Spring:
              if(state == STATE_SPRING &amp;&amp; y_speed &lt; 0 &amp;&amp; animation != "spring")
              { 
                 animation = "spring";
              }
              if(state == STATE_SPRING &amp;&amp; y_speed &gt; 0 &amp;&amp; animation != "walk")
              { 
                 animation = "walk";
              }              
              if(state != STATE_SPRING &amp;&amp; y_speed &gt; 0 &amp;&amp; animation == "spring")
              {
                 animation = "walk";              
              }
    
           // Hurt:
              if(state == STATE_HURT &amp;&amp; animation != "hurt")
              {
                 animation = "hurt";
              }
    
           // Breath:
              if(state == STATE_BREATH &amp;&amp; animation != "breath")
              {
                 animation = "breath";
              }  
    
           // Flying:
              if(state == STATE_FLY &amp;&amp; physic_mode == 0 &amp;&amp; animation != "fly")
              {
                 animation = "fly";
              }
              
           // Swimming:
              if(state == STATE_FLY &amp;&amp; physic_mode == 1 &amp;&amp; animation != "swim")
              {
                 animation = "swim";
              }                
    
           // Flying exhausted:
              if(state == STATE_FLYDROP &amp;&amp; physic_mode == 0 &amp;&amp; animation != "fly exhausted")
              {
                 animation = "fly exhausted";
              }
              
           // Swimming exhausted:
              if(state == STATE_FLYDROP &amp;&amp; physic_mode == 1 &amp;&amp; animation != "swim exhausted")
              {
                 animation = "swim exhausted";
              }  
              
           // Glide:
              if(state == STATE_GLIDE &amp;&amp; animation != "glide")
              {
                 animation = "glide";
              } 
              
           // Glide drop:
              if(state == STATE_GLIDE_DROP &amp;&amp; animation != "glide drop")
              {
                 animation = "glide drop";
              } 
              
           // Climb:
              if(state == STATE_CLIMB &amp;&amp; is_ledge_grabbing == 0 &amp;&amp; animation != "climb")
              {
                 animation = "climb";
              } 
              
           // Ledge climb:
              if(state == STATE_CLIMB &amp;&amp; is_ledge_grabbing == 1 &amp;&amp; animation != "ledge climb")
              {
                 animation = "ledge climb";
              }                                           
              
           // Slide:
              if(state == STATE_SLIDE &amp;&amp; animation != "slide")
              {
                 animation = "slide";
              }                                                                                                                               
    }
              
    // Death:
       if(state == STATE_DEATH)
       {
          if(has_drowned == false)
          {
             animation = "death";
          }
          else
          {
             animation = "drown";
          }
       }             
    
 // ########################################################################################################################## //
 
 // Set animation directions:
 
    if(state != STATE_SPINDASH &amp;&amp; state != STATE_LOOKUP &amp;&amp; state != STATE_CROUCH
    &amp;&amp; state != STATE_ROLL     &amp;&amp; state != STATE_SKID   &amp;&amp; state != STATE_JUMP
    &amp;&amp; state != STATE_CLIMB    &amp;&amp; state != STATE_HURT &amp;&amp; grab_moving == 0)
    {
       // Change direction depending on input and speed:
          if(input_left  &amp;&amp; x_speed &lt;= 0) { animation_direction = -1}
          if(input_right &amp;&amp; x_speed &gt;= 0) { animation_direction =  1}
    }

 // Rolling direction:
    if(state == STATE_ROLL)
    {
       // Change direction depending on input and speed:    
          if(x_speed &gt; 0 &amp;&amp; ground)      { tails_tail_direction =  1 }
          if(x_speed &lt; 0 &amp;&amp; ground)      { tails_tail_direction = -1 }          
          if(x_speed &gt; 0 &amp;&amp; input_right) { animation_direction  =  1 }
          if(x_speed &lt; 0 &amp;&amp; input_left)  { animation_direction  = -1 }         
    }

 // Jumping direction:
    if(state == STATE_JUMP &amp;&amp; !jump_lock || state == STATE_SPRING)
    {
      // Change direction depending on input:
         if(input_right) { animation_direction =  1 } 
         if(input_left)  { animation_direction = -1 }
         if(input_left &amp;&amp; input_right)
         {
            animation_direction = animation_direction;
         }
    }

  // Change direction in the air:
     if(!ground &amp;&amp; state = STATE_DEFAULT){
     
      // Change direction depending on input:
         if(input_right) { animation_direction =  1 }  
         if(input_left)  { animation_direction = -1 }       
                  
     }    
    
 // ########################################################################################################################## //
 
 // Modify animation speeds:
  
 // Walking:
    if(player_index == CHAR_SONIC)
    {
       if(animation = "walk")
       {
          animation_speed = min(0.30, max(0.05+abs(x_speed)/25));
       }
    }
    if(player_index == CHAR_TAILS)
    {
       if(animation = "walk")
       {
          animation_speed = min(0.25, max(0.10+abs(x_speed)/25));
       }
    }    
    if(player_index == CHAR_KNUCKLES)
    {
       if(animation = "walk")
       {
          animation_speed = min(0.25, max(0.05+abs(x_speed)/25));
       }
    }
        
 // Running:
    if(animation = "run")
    {
       animation_speed = 0.20+abs(x_speed)/25;
    }    
 
 // Jumping:
    if(player_index == CHAR_SONIC || player_index == CHAR_KNUCKLES)
    { 
       if(state == STATE_JUMP &amp;&amp; dropdash_flag &lt; 2)
       {
          animation_speed = animation_rendering_speed;
       }
    }
    if(player_index == CHAR_TAILS)
    { 
       if(state == STATE_JUMP)
       {
          animation_speed           = 0.25;
          animation_rendering_speed = 0.25;
       }
    }
    
    
  // Rolling:
    if(player_index == CHAR_SONIC || player_index == CHAR_KNUCKLES)
    {   
       if(state = STATE_ROLL)
       {
          if(ground == true)
          {
             animation_speed           = 0.25+abs(x_speed)/12;
             animation_rendering_speed = animation_speed;
          }
          else
          {
             animation_speed = animation_rendering_speed;
          }
       }
    }
    if(player_index == CHAR_TAILS)
    {   
       if(state = STATE_ROLL)
       {
          animation_speed           = 0.25;
          animation_rendering_speed = 0.25;
       }
    }
        
  // Limit rolling animation speed:
     if(animation = "roll")
     {
        if(animation_rendering_speed &gt; 1.5)
        {
           animation_rendering_speed = 1.5;
        }
        if(animation_speed &gt; 1.5)
        {
           animation_speed = 1.5;
        }        
     }

  // If we hit a wall, reset the animation speed.
     if(!ground &amp;&amp; y_speed &gt;= 0 &amp;&amp; ((player_collision_check(COL_RIGHT, MASK_BIG, x, y, angle, -1) &amp;&amp; input_right) || (player_collision_check(COL_LEFT, MASK_BIG, x, y, angle, -1) &amp;&amp; input_left)))
     {
        if(state == STATE_JUMP || state == STATE_ROLL)
        {
           animation_speed           = 0.25;
           animation_rendering_speed = 0.25;
        }
     }    
    
 // ########################################################################################################################## //    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite rotation.
 // This is used for rotating the players sprite.
 
 // Exit if not initialized, death or hurt.
    if(initialized = false || state = STATE_DEATH || state == STATE_HURT) exit;
 
 // Change animation angle values:
    if(ground)
    {
       if(player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_solid_no_angle) || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_platform_no_angle)
       || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer0_no_angle) || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer1_no_angle))
       {       
          animation_angle_mod = 0;
       }
       else
       {
          var _angMod;
          _angMod = animation_angle_mod;
             
          if(angle &gt;= 0 &amp;&amp; angle &lt;= 180)
          {
             if(angle &lt; 36)
             {
                _angMod = 0;
             }
                else
             {
                _angMod = angle;
             }
          }
          if(angle &gt;= 180 &amp;&amp; angle &lt;= 360)
          {
             if(angle &gt; 360-36)
             {
                _angMod = 0;
             }
             else
             {
                _angMod = angle;
             }
          }
          if(abs(angle_difference(animation_angle_mod, _angMod))&lt;45)
          {
             animation_angle_mod = rotate_towards(_angMod, animation_angle_mod, max(4, abs(x_speed)));
          }
          else
          {
             animation_angle_mod = _angMod;
          }
       } 
    }
    else
    {
       animation_angle_mod = rotate_towards(0, animation_angle_mod, 4)
    }
 
 // Rotate:   
    if(global.angle_mode == 0)
    { 
       animation_angle  = round(animation_angle_mod/45)*45;
       tails_tail_angle = round(animation_angle_mod/45)*45;
    }
    else
    {
       animation_angle  = animation_angle_mod;
       tails_tail_angle = animation_angle_mod;     
    } 
    
 // Set angle to zero and exit if we're not using a animation that can be rotated.
    if(animation == "idle" || animation == "idle bored" || animation == "lookup" || animation == "crouch" || animation == "spindash" || animation == "roll" || animation == "push" || animation == "hurt" 
    || animation == "balance" || animation == "balance 2" || animation == "fly" || animation == "swim" || animation == "fly exhausted" || animation == "swim exhausted" || animation == "glide"
    || animation == "glide drop" || animation == "slide" || animation == "ledge climb" || animation == "climb") 
    {
       animation_angle = 0;
    }
    
 // Set the Angle of Miles tail.
    if((state = STATE_JUMP || state = STATE_ROLL || animation = "roll"))
    {
        if(ground == false)
        {
           tails_tail_angle = point_direction(xprevious, yprevious, x, y);
           if(tails_tail_direction != 1)
           {
              tails_tail_direction = 1;
           }
        }
    }     
 
 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep within boundaries

    if(x &lt;= (camera.limit_left+sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &lt; 0.0)
    {
       x_speed   = 0;
       x         = (camera.limit_left+sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation = "idle";
       }
    }
    else
    if(x &gt;= (camera.limit_right-sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &gt; 0.0)
    {
       x_speed   = 0;
       x         = (camera.limit_right-sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation = "idle";
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform reset.
 // In order to prevent the player from bouncing off or loosing collision on platform, wait at least 30 frames before reseting the check.
    
    if((ground == false || place_meeting(x, y, par_platform) == false) &amp;&amp; platform_check == 1)
    {
       if(platform_frames &gt; 0)
       {
          platform_frames -= 1;
       }
       else if(platform_frames &lt;= 0)
       {
               platform_check  = 0;
               platform_frames = 30;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Water splash.

    if(global.water_position != -1)
    {
       if ((abs(y_speed) &gt;= 0)
       &amp;&amp; ((y &gt; global.water_position &amp;&amp; previous_y &lt; global.water_position)
       ^^  (y &lt; global.water_position &amp;&amp; previous_y &gt; global.water_position)))
       {
           dummy_effect_create(spr_water_splash, 0.25, x, global.water_position-8, -999996, 0);
           aud_play_sound(general_water_splash, global.sfx_volume, 1, 0, 1);
       }
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Receive inputs.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
  
 // Key held.   
    input_up               = keyboard_check(global.key_up);
    input_down             = keyboard_check(global.key_down);
    input_right            = keyboard_check(global.key_right);
    input_left             = keyboard_check(global.key_left);
    input_action           = keyboard_check(global.key_action);
    input_special          = keyboard_check(global.key_special);
    
 // Key press.
    input_up_pressed       = keyboard_check_pressed(global.key_up);
    input_down_pressed     = keyboard_check_pressed(global.key_down);
    input_right_pressed    = keyboard_check_pressed(global.key_right);
    input_left_pressed     = keyboard_check_pressed(global.key_left);
    input_action_pressed   = keyboard_check_pressed(global.key_action);
    input_special_pressed  = keyboard_check_pressed(global.key_special);    

 // Key release.    
    input_up_released      = keyboard_check_released(global.key_up);
    input_down_released    = keyboard_check_released(global.key_down);
    input_right_released   = keyboard_check_released(global.key_right);
    input_left_released    = keyboard_check_released(global.key_left);
    input_action_released  = keyboard_check_released(global.key_action);
    input_special_released = keyboard_check_released(global.key_special);    

 // Disable input if both left and right is being held.
    if(input_left &amp;&amp; input_right)
    {
       input_left  = false;
       input_right = false;
    }
    
 // Input alarm.
    if(input_alarm)
    {
       if(input_alarm_dir == 1)
       {
          input_right = false;
       }
       if(input_alarm_dir == -1)
       {
          input_left = false;
       }
    }
    
 // Input locks (spring)
    if(input_lock_l)
    {
       input_left = false;
    }
    if(input_lock_r)
    {
       input_right = false;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Modify physics.

 // Previous Positions:
    previous_x = x;
    previous_y = y;
    
 // Switch Physic Modes:
    if(global.water_position != -1)
    {
       if(y &lt; global.water_position)
       {
          if(physic_mode != 0)
          {
             physic_mode = 0
          }
       } 
       if(y &gt; global.water_position)
       {
          if(physic_mode != 1)
          {
             physic_mode = 1;
          }   
       }   
    }
     
 // Get/Set physics for each character.
    if(player_index == CHAR_SONIC)
    {
       player_physics_sonic()
    }
    
    if(player_index == CHAR_TAILS)
    {
       player_physics_tails()
    }    
    
    if(player_index == CHAR_KNUCKLES)
    {
       player_physics_knuckles()
    }    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death.

    if(death_timer == -1) exit;
    
    if(state == STATE_DEATH)
    {
       // Throw the player into the air.
          if(death_timer == -5)
          {
             angle = 0;
             if(physic_mode == 0)
             {
                y_speed = -7;
             }
             death_timer = 120;
             depth       = -999995;
             
             // Fade out the audio. 
                with(obj_audio)
                {
                     fadeout_flag = 1;
                }
                
             // Decrease lives.
                global.player_lives -= 1;
                if(global.player_lives &lt; 0)
                {
                   global.player_lives = 0;
                }
                
             // Play death/drown sound.
                if(has_drowned == false)
                {
                   aud_play_sound(player_die, global.sfx_volume, 1, 0, 0);
                }
                else
                {
                   aud_play_sound(player_drowned, global.sfx_volume, 1, 0, 0);                
                }
                audio_stop_sound(player_flying);
                audio_stop_sound(player_flying_drop);
                
             // Destroy shields.
                shield = 0;
                with(shield_obj)
                {
                     instance_destroy();
                }
                shield_obj = noone;                
          }
          
       // Set Gravity:
          if(physic_mode == 0){
             y_speed += 0.21875;
          }else{
             y_speed += 0.0625;
          }
          y  += y_speed;          
          
       // Decrease timer.
          if(death_timer &gt; 0)
          {
             death_timer -= 1;
          }
          else if(death_timer == 0)
          {
             death_timer = -1;
             if(global.player_lives &gt; 0)
             {
                instance_create(0, 0, obj_fade_restart);
             }
             else
             {  
                global.previous_room = room;
                instance_create(0, 0, obj_game_over);            
             }
          }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Die from Heights.

    if(global.death_height == -1)
    {
       if(y &gt;= room_height &amp;&amp; state != STATE_DEATH)
       {
          state = STATE_DEATH;
       }
    }
    else
    {
       if(y &gt;= global.death_height &amp;&amp; state != STATE_DEATH)
       {
          state = STATE_DEATH;
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision Detecting and Movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;

 // Set temporal sample variables:
    var _steps, _samples;
    
 // Limit the horizontal speed:
    if(x_limit)
    {
       x_speed = clamp(x_speed, -xspeed_max, x_speed_max);
    }
    
 // Set steps/samples:
    _steps = 1;
    if(x_sample &gt; 0)
    {
       _steps += floor(abs(x_speed)/x_sample);  
    }
    _samples = x_speed/_steps;
     
 // Move horizontally:
    repeat(_steps)
    {
           x += dcos(angle)*_samples;
           y -= dsin(angle)*_samples;
           
           // Move outside terrain if stuck:
              while(_samples &gt; 0 &amp;&amp; (player_collision_check(COL_RIGHT, MASK_MID, x, y, angle, -1) == true))
              {
                    x -= dcos(angle);
                    y += dsin(angle);                  
              }
              while(_samples &lt; 0 &amp;&amp; (player_collision_check(COL_LEFT, MASK_MID, x, y, angle, -1) == true))
              {
                    x += dcos(angle);                   
                    y -= dsin(angle);
              } 
        
           // Object handling:
                         
           // Handling:
              player_handle_layers();
              player_handle_springs();
              player_handle_watersurface();
              player_handle_tunnels();
              player_handle_platforms();
              player_handle_breakable_walls();
                    
           // Terrain/Slope movement:                         
              if(ground)
              {
                 while(player_collision_check(COL_MAIN, x, y, -1, -1, -1))
                 {
                       x -= dsin(angle);
                       y -= dcos(angle);
                 }
                 if(player_collision_check(COL_SLOPE, MASK_MID, x, y, angle, -1))
                 {
                    while (!player_collision_check(COL_MAIN, x, y, -1, -1, -1))
                    {
                              x += dsin(angle);
                              y += dcos(angle); 
                    }
                 }
              
              // Get new angles:
                 if(y_allow)
                 {
                    if(player_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
                    {
                       angle = player_calculate_angle(x, y, angle);
                    }
                 }
              }   
        
           // Object handling:
              player_handle_rings();
              player_handle_obstacles();
              player_handle_monitors("side");
              player_handle_breakable_walls();
              player_handle_corkscrews();
              player_handle_enemies();
              player_handle_spikes();
              player_handle_tunnels();
              
           // Abort.
              if(x_speed == 0)
              {
                 break;
              }                  
    }
    
 // Move vertically:
    if(y_allow)
    {
    
       // Limit vertical speeds:
          if(y_limit)
          {
             y_speed = clamp(y_speed, -y_speed_max, y_speed_max);
          }
          
       // Set steps/samples:
          if(!ground)
          {
                 var _ysteps, _ysamples;
                 _ysteps = 1;
                 if(x_sample &gt; 0)
                 {
                    _ysteps += floor(abs(y_speed)/y_sample);
                 }
                 
                 _ysamples = y_speed/_ysteps;
                 
                 repeat(_ysteps)
                 {                   
                        x += dsin(angle)*_ysamples;
                        y += dcos(angle)*_ysamples;
           
                        // Move outside terrain if stuck:
                           while(_ysamples &lt; 0 &amp;&amp; (player_collision_check(COL_TOP, MASK_MID, x, y, 0, -1) == true))
                           {
                                 x += dsin(angle);                                 
                                 y += dcos(angle);
                           }
                           while(_ysamples &gt; 0 &amp;&amp; (player_collision_check(COL_BOTTOM, MASK_MID, x, y, 0, -1) == true))
                           {
                                 x -= dsin(angle);                                
                                 y -= dcos(angle);
                           }  
              
                        // Handling:
                           player_handle_layers();     
                           player_handle_grabs();                      
                           player_handle_monitors("top");
                           player_handle_breakable_walls();
                           player_handle_corkscrews();    
                           player_handle_enemies();
                           player_handle_springs();
                           player_handle_watersurface();
                           player_handle_tunnels();     
                           player_handle_platforms();                           
                                                                         
                        // Check for landing:
                           if(y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_BIG, x, y, 0, -1))
                           {                           
                              // Set Calculate angles:
                                 if(player_collision_check(COL_LEFT_EDGE, x, y, 0, -1, -1) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, 0, -1, -1))
                                 {
                                    player_angle(player_calculate_angle(x, y, angle));
                                 }else{
                                    player_angle(0);
                                 }
                                 
                              // Check if landed on obstacles:
                                 if(player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_obstacles))
                                 {
                                    player_angle(0);
                                 }                  
                                 
                              // Change horizontal speed upon landing on flat terrain or slopes.          
                                 if(abs(x_speed) &lt;= abs(y_speed) &amp;&amp; angle_relative &gt;= 22.5 &amp;&amp; angle_relative &lt;= 337.5)
                                 {
                                    x_speed = -y_speed*sign(dsin(angle_relative));
                                    if(angle_relative &lt; 45 || angle_relative &gt; 315)
                                    { 
                                       x_speed *= 0.5; 
                                    }
                                 }
                                 
                              // Set ground flag.
                                 y_speed = 0;
                                 ground  = true;
                                 
                              // Return to normal state:
                                 if(state == STATE_HURT || state == STATE_JUMP)
                                 {
                                    state = STATE_DEFAULT;
                                 }
                                 
                              // Return to normal state after flying.
                                 if(state == STATE_FLY || state == STATE_FLYDROP)
                                 {
                                    state          = STATE_DEFAULT;
                                    y_acceleration = y_accel_common;
                                 }                                 
                           }
                           
                        // Ceiling handling:
                           if((y_speed &lt; 0 &amp;&amp; player_collision_check(COL_TOP, MASK_LARGE, x, y, 0, -1)) &amp;&amp; (!player_collision_check(COL_TOP_OBJECT, MASK_LARGE, x, y, angle, par_obstacles)))
                           {
                              // Set angle:
                                 player_angle(180);                                 
                              
                              // Check if it's possible to land on the ceiling.
                                 if(player_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
                                 {
                                    // Calculate angle:
                                       player_angle(player_calculate_angle(x, y, angle));
                                       
                                    // Check if the angle isn't flat:
                                       if(angle_relative &gt; 160 &amp;&amp; angle_relative &lt; 200)
                                       {
                                          player_angle(0);
                                          y_speed = 0;
                                       }
                                       
                                    // If the angle isn't flat, set new movement values:
                                       x_speed -= dsin(angle)*y_speed;
                                       ground   = true;
                                 }
                                 else
                                 {
                                    // Set angle:
                                       player_angle(0);
                                       y_speed = 0;
                                       if not(ground)
                                       {
                                          break;
                                       }
                                 }                               
                           }   
                           
                           // Do another wall Collision check to prevent any glitches:                         
                              while(player_collision_check(COL_RIGHT, MASK_MID, x, y, angle, -1))
                              {
                                    x -= dcos(angle);
                                    y += dsin(angle);
                              }    
                              while(player_collision_check(COL_LEFT, MASK_MID, x, y, angle, -1))
                              {
                                    x += dcos(angle);
                                    y -= dsin(angle);
                              }
                           
                           // Handling:
                              player_handle_rings();
                              player_handle_grabs();
                              player_handle_obstacles();                              
                              player_handle_monitors("side");
                              player_handle_breakable_walls();
                              player_handle_corkscrews();
                              player_handle_spikes();
                              player_handle_tunnels();

                              
                           // Abort:
                              if(y_speed == 0)
                              {
                                 break; 
                              }                                                                                                                                                                                  
                 } 
          }    
            
          // Fall off the ground if the edges aren't colliding         
             if(ground &amp;&amp; angle != 0){
                if(!player_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1) || !player_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1)){
                   if(floor_mode == 1 || floor_mode == 3){           
                      y_speed       = -(dsin(angle_relative) * g_speed)                                
                      x_speed       =   dcos(angle_relative) * x_speed;
                      launch_lock   = 3;
                      ground        = false;              
                      shield_usable = false;               
                   }else{
                      ground  = false;
                      y_speed = -dsin(angle)*x_speed;
                      x_speed =  dcos(angle)*x_speed;                   
                   }
                }
             }                                                      
    }

 // Launch lock:
    if(launch_lock)
    {
       launch_lock -= 1;
       x_speed = 0;
    }if(launch_lock &lt; 0) { launch_lock = 0 }
 
 // Get ground speed:
    player_gspeed();
 
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;

 // Input alarm. Ignores left or right input if above zero.
    if(input_alarm)
    {
       input_alarm -= 1;
    }else{
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
    if(input_alarm &amp;&amp; angle == 0)
    {
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
 // Store Accel/Decel changes.
    if(ground)
    {
       x_temp_accel    = x_acceleration;
       x_temp_decel    = x_deceleration;
       x_temp_friction = x_temp_accel;
    }else{
       x_temp_accel    = x_acceleration * 2;
       x_temp_decel    = 0;
       x_temp_friction = 0;
    }
    
 // Exit if we're not allowing x movement:
    if(x_allow == false) exit;
    
 // Decelerate on slopes:
    if(state != STATE_SLIDE)
    {
       if(state = STATE_ROLL &amp;&amp; ground)
       {
          // Rolling up a slope:
             if((angle_relative &lt; 180 &amp;&amp; x_speed &gt; 0) || (angle_relative &gt; 180 &amp;&amp; x_speed &lt; 0))
             {
                x_speed -= dsin(angle_relative)*roll_decel_up;
             }else{
                x_speed -= dsin(angle_relative)*roll_decel_down;
             }
       }else{
          // Decelerate normally:
             if(ground &amp;&amp; ((angle_relative &gt; 35 &amp;&amp; angle_relative &lt; 330) || round(x_speed) != 0 || input_alarm != 0))
             {
                x_speed -= dsin(angle_relative) * 0.125;
             }
       }
    }
    
 // Continue if in one of the following states.
    if((state == STATE_DEFAULT || state = STATE_WOBBLE || (state = STATE_JUMP &amp;&amp; !jump_lock) || state == STATE_SKID || state == STATE_FLY || state == STATE_FLYDROP || state == STATE_SPRING || state == STATE_CORKSCREW || state == STATE_CORKSCREW_ROLL || state == STATE_GLIDE_DROP) &amp;&amp; (state != STATE_GLIDE &amp;&amp; state != STATE_SLIDE &amp;&amp; state != STATE_CLIMB))
    {
       // Handle Accel/Decel:
          if((ground &amp;&amp; input_alarm == 0))
          {
             if(input_left == true)
             {
                if(x_speed &gt; 0)
                {
                   x_speed -= x_temp_decel;
                }else{
                   if(x_speed &gt; -x_speed_top)
                   {
                      x_speed -= x_temp_accel;
                   }
                }
             }else if(input_right == true)
             {
                if(x_speed &lt; 0)
                {
                   x_speed += x_temp_decel;
                }else{
                   if(x_speed &lt; x_speed_top)
                   {
                      x_speed += x_temp_accel;
                   }
                }                
             }else{
                x_speed -= min(abs(x_speed), x_temp_friction)*sign(x_speed);
             }
          }else{
             // Air Cap:
                if(y_speed &gt; 16)
                {
                   y_speed = 16;
                }
                
             // Air acceleration:
                if(input_right)
                {
                   if(state == STATE_FLY || state == STATE_FLYDROP || state == STATE_GLIDE_DROP)
                   {
                      if(x_speed &lt; 0)
                      {
                         x_speed += x_temp_accel;
                      }
                      else if(x_speed &lt; x_speed_top)
                      {
                              x_speed += x_air_accel;
                      }                      
                   }
                   else
                   {
                      x_speed += x_air_accel;
                   }
                }
                
                if(input_left)
                {
                   if(state == STATE_FLY || state == STATE_FLYDROP || state == STATE_GLIDE_DROP)
                   {
                      if(x_speed &gt; 0)
                      {
                         x_speed -= x_temp_accel;
                      }
                      else if(x_speed &gt; -x_speed_top)
                      {
                              x_speed -= x_air_accel;
                      }                      
                   }
                   else
                   {
                      x_speed -= x_air_accel;
                   }
                }
          }
    }
   
 // Fall if there's not enough speed:
    if(angle_relative &gt; 45 &amp;&amp; angle_relative &lt; 315 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; tunnel_lock = 0)
    {
       if(angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
       {
          y_speed = -dsin(angle_relative)*x_speed;
          x_speed =  dcos(angle_relative)*x_speed;
          ground  = false;
       }else{
          input_alarm = 40;
          if(input_alarm_dir == 0)
          {
             input_alarm_dir = animation_direction;
          }
       }
    }
     
 // Get new angle:
    if(ground &amp;&amp; player_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1)
              &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
    {
       player_angle(player_calculate_angle(x, y, angle));
    }else{
       player_angle(0);
    }
   
 // Full stop when colliding with a wall.
    if((x_speed &gt; 0 &amp;&amp; player_collision_check(COL_RIGHT, MASK_BIG, x, y, angle, -1)) || (x_speed &lt; 0 &amp;&amp; player_collision_check(COL_LEFT, MASK_BIG, x, y, angle, -1))){
        x_speed = 0;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Exit if we're not allowing x movement:
    if(y_allow == false) exit;
            
 //  Return to a normal state:
     if(ground)
     {
        y_speed = 0;
        if(state = STATE_JUMP || state = STATE_HURT || state == STATE_SPRING)
        {
           if(state = STATE_HURT)
           {
              x_speed = 0;
           }
           state = STATE_DEFAULT;
        }
        
        // Check if the player is really grounded:
           if(player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == false)
           {
              ground = false;
              player_angle(0);
           }
     }
     
 // Otherwise, add gravity:
    if(!ground)
    {
           // Gravity:           
              if(state != STATE_CORKSCREW &amp;&amp; state != STATE_CORKSCREW_ROLL)
              {
                 y_speed += y_acceleration;
              }
              
           // Check if we landed:
              if(y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == true)
              {
                 // We grounded:
                    ground = true;
                    
                 // Return to normal state:
                    if(state = STATE_JUMP || state == STATE_FLY || state == STATE_FLYDROP || state = STATE_HURT)
                    {
                       if(state = STATE_HURT)
                       {
                          x_speed = 0;
                       }
                       state = STATE_DEFAULT;
                    }
              }
              
           // Check if we're in the air but collide with a ceiling.
              if(y_speed &lt; 0 &amp;&amp; player_collision_check(COL_TOP, MASK_BIG, x, y, angle, -1) == true)
              {
                 y_speed = 0;
                 if(state = STATE_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; y_speed == 0)
                 { 
                    state = STATE_ROLL;
                 }
              }
    }
     
 // Reset horizontal speed after getting hurt.
    if(y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_MAIN, x, y, angle, -1) == true)
    {
       if(state == STATE_HURT)
       {
          x_speed = 0;
          state   = STATE_DEFAULT;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Air drag and floor mode.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Air Drag:
    if(ground == false &amp;&amp; state != STATE_HURT)
    {
       if(y_speed &lt; 0 &amp;&amp; y_speed &gt;= -4)
       {
          x_speed -= ((x_speed / 0.125) / 256);
       }
    }
    
 // Return the floor mode:
    floor_mode = round(angle/90) mod 4;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input disabling.

 // Exit if not initialized, death or hurt.
    if(initialized = false || state = STATE_DEATH || state == STATE_HURT) exit;
    
 // Enable input after jumping:
    if(input_lock_s &amp;&amp; !jump_lock &amp;&amp; state == STATE_JUMP)
    {
       lock_timer      = 0;
       input_alarm_dir = 0;
    }
    
 // Disable direction lock when the angle is equal to 0.
    if(input_alarm_dir != 0 &amp;&amp; angle == 0)
    {
       input_alarm_dir = 0;
    }
    
 // Disable spring lock:
    if(lock_timer &lt; 1 &amp;&amp; input_lock_s == true)
    {
       input_lock_s = 0;
       input_lock_l = 0;
       input_lock_r = 0;
    }
    
 // Enable locks:
    if(input_lock_s &amp;&amp; x_speed &gt; 0)
    {
       input_lock_l = 1;
       input_right  = 1;
    }
    else if(input_lock_s &amp;&amp; x_speed &lt; 0)
    {
            input_lock_r = 1;
            input_left   = 1;
    }
    
 // Decrease timers.
    if(lock_timer)
    {
       lock_timer -= 1;
    }if(lock_timer &lt; 0) { lock_timer = 0 };


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    if(x_allow == false &amp;&amp; y_allow == false) exit;
    
 // Shield abilities:
    player_state_shield();    
    
 // Sonic only - Dropdash:
    if(player_index == CHAR_SONIC)
    {
       player_state_dropdash();
    }
    
 // Tails only - Flying:
    if(player_index == CHAR_TAILS)
    {
       player_state_fly();
    }
    
 // Knuckles only - Glide, Climb and Slide:
    if(player_index == CHAR_KNUCKLES)
    {
       player_state_glide();
       player_state_climb();
       player_state_slide();
    }
 
 // Hanging:
    player_state_grab();    
 
 // Collapsing tiles have to be handled differently to prevent that the Character gets stuck or gets pushed away.
 // This is why the following code exists here. Anywhere else, we'll just get stuck and won't be able to Jump.
    if(place_meeting(x, y + y_speed, par_collision_collapse_tiles)){
       while(!place_meeting(x, y + sign(y_speed), par_collision_collapse_tiles)){
              y += sign(y_speed);
       }
       ground = true;   
    }    

 // Jumping:
    player_state_jump();
    
 // Looking up:
    player_state_lookup();
    
 // Crouching:
    player_state_crouch();
    
 // Spindash:
    player_state_spindash();
    
 // Rolling:
    player_state_roll();
    
 // Skidding:
    player_state_skid();

 // Pushing:
    player_state_push();
    
 // Balancing:
  //  player_state_edgewobble();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Invincibility/Speedup Timers.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Decrease invincibility timer.
    if(invincibility_timer &gt; -1)
    { 
       invincibility_timer -= 1;
       if(invincibility_timer == 0)
       {
          invincibility       =  0;
          invincibility_timer = -1;
          if(animation_alpha &lt; 1)
          {
             animation_alpha = 1;
          }
       }
    } 

 // Stop jingles.
    if(audio_is_playing(jingle_invincibility) &amp;&amp; invincibility == 0)
    { 
       audio_stop_sound(jingle_invincibility);
    }
    
 // Don't show shields.
    if(shield != 0 &amp;&amp; invincibility &gt; 1)
    { 
       if(shield_obj != noone)
       {
          shield_obj.visible = false;
       }
    }
    else
    {
       if(shield_obj != noone)
       {
          shield_obj.visible = true;
       }     
    }
    
 // Start timer once we land after being hit.
    if(invincibility == 1 &amp;&amp; invincibility_timer == -1)
    {
       if(ground)
       { 
          invincibility_timer = 120;
       }
    }
 
 // Sparkles.
    if(invincibility &gt; 1)
    {
       repeat(1)
       {
              instance_create(x, y, obj_invincibility_sparkle)
       }
    }
    
 // Speedshoe timer.
    if(speedshoe_timer &gt; 0)
    {  
       speedshoe_timer -= 1;
    }
    else
    {
       if(speedshoe_timer == 0)
       {
          if(speedshoe == true)
          {
             speedshoe = false;
          }
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Underwater handling.

 // Don't run in certain cases:
    if(state != STATE_DEATH &amp;&amp; !instance_exists(obj_results))
    {
       if(physic_mode == 1)
       {
          // Destroy the countdown if we have a bubble shield and keep the drown timer fixed.
             if(shield == SHIELD_BUBBLE)
             {
                drown_timer = 1800;
                if(instance_exists(drown_counter))
                {
                   with(drown_counter)
                   {
                        instance_destroy();
                   }
                   drown_counter = noone;     
                }
                exit;
             }
             
          // Decrease our drown timer.
             if(drown_timer &gt; 0)
             {
                drown_timer -= 1;
             }
             
          // Start the drowning theme.
             if(drown_timer == 650)
             {
               if(audio_is_playing(jingle_drown) == false)
               {
                  aud_play_sound(jingle_drown, global.sfx_volume, 1, 0, 1);
               }
               if(instance_exists(obj_water_alarm) == false)
               {
                  drown_counter = instance_create(x, y-32, obj_water_alarm);
                  drown_counter . parent = id;
               }
             }
             
          // Kill the player.
             if(drown_timer == 0)
             {
                drown_timer = 1800;
                state       = STATE_DEATH;
                has_drowned = true;
                if(audio_is_playing(jingle_drown))
                {
                   audio_stop_sound(jingle_drown);
                }
             }
             
          // Bubble state.
             if(state == STATE_BREATH &amp;&amp; !ground)
             {
                if(bubble_timer &lt; 1)
                {
                   x_speed = 0;
                   y_speed = 0;
                }
                if(input_left || input_right)
                {
                   x_speed += animation_direction*.025;
                }
                if(bubble_timer &lt; 20)
                {
                   bubble_timer += 1;
                }
                else
                {
                   bubble_timer = 0;
                   animation    = "walk";
                   state        = STATE_DEFAULT;
                }
                drown_timer = 1800;
                if(instance_exists(drown_counter))
                {
                   with(drown_counter)
                   {
                        instance_destroy();
                   }
                   drown_counter = noone;                        
                }
                if(audio_is_playing(jingle_drown))
                {
                   audio_stop_sound(jingle_drown);
                }
             }
             else if(state == STATE_BREATH &amp;&amp; ground)
             {
                     state       = STATE_DEFAULT;
                     drown_timer = 1800;
                     if(instance_exists(drown_counter))
                     {
                        with(drown_counter)
                        {
                             instance_destroy();
                        }
                        drown_counter = noone;                             
                     }                
                     if(audio_is_playing(jingle_drown))
                     {
                        audio_stop_sound(jingle_drown);
                     }                         
             }
                                   
          // Remove bubble timer.
             if(state != STATE_BREATH)
             {
                bubble_timer = 0;
             }           
             
          // Alarm sounds.
             if(drown_timer mod 400 == 0)
             {
                if(audio_is_playing(jingle_drown) == false)
                {
                   aud_play_sound(general_alarm_count, global.sfx_volume, 1, 0, 0);
                }                
             }
             
          // Air bubbles. 
             if(drown_timer mod 78 == 0 &amp;&amp; drown_timer &gt; 600)
             {
                bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_air_bubble);
                bubble . bubble_index = choose(0, 1, 2, 1, 3);
             }
       }
    }
    
 // Above water, reset timers and destroy misc. stuff.
    if(physic_mode == 0)
    {
       drown_timer = 1800;
       if(instance_exists(drown_counter))
       {
          with(drown_counter)
          {
                instance_destroy();
          }
          drown_counter = noone;
       }
       if(audio_is_playing(jingle_drown))
       {
          audio_stop_sound(jingle_drown);
       }  
    }
    
 // Drowning bubbles.
    if(state == STATE_DEATH &amp;&amp; has_drowned == true)
    {
       if(breath_timer != 0)
       {  
          breath_timer -= 1;
          if(random(4) &gt;= 2)
          {
             bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_air_bubble);
             bubble . bubble_index = choose(0, 1, 2, 1, 3);
             bubble . depth        = -999996;             
          }
       }
    }



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Playable.

    if not(initialized) exit;

    if not(debug_mode)
    {        
        // Draw Player:
           if(invincibility == 1 &amp;&amp; invincibility_timer &gt; 0)
           {
             if((global.object_time div 60) mod 3)
             {
                 if(tails_tail_sprite != noone)
                 {
                    draw_sprite_ext(tails_tail_sprite, floor(tails_tail_frame), floor(x+tails_tail_x), floor(y+tails_tail_y), tails_tail_direction, 1, tails_tail_angle, animation_color, animation_alpha); 
                 }             
                 draw_sprite_ext(sprite, floor(animation_frame), floor(x), floor(y), animation_direction, 1, animation_angle, animation_color, animation_alpha);                     
             }
           }
           else
           {
              if(tails_tail_sprite != noone)
              {
                 draw_sprite_ext(tails_tail_sprite, floor(tails_tail_frame), floor(x+tails_tail_x), floor(y+tails_tail_y), tails_tail_direction, 1, tails_tail_angle, animation_color, animation_alpha); 
              }
              draw_sprite_ext(sprite, floor(animation_frame), floor(x), floor(y), animation_direction, 1, animation_angle, animation_color, animation_alpha);    
           }
                         
        // Draw Spindash dust:
         if(state == STATE_SPINDASH)
           {
              draw_sprite_ext(spr_spindash_dust, current_time div 40, floor(x-animation_direction*1), floor(y+1), animation_direction, 1, 0, c_white, 1);  
           }
        
        // Draw Shields:    
           if(shield == SHIELD_FIRE)
           {
              if(shield_obj == noone)
              {
                 shield_obj = instance_create(x, y, obj_player_fire_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_flame, global.sfx_volume, 1, 0, 0);
              }
           }
           if(shield == SHIELD_BUBBLE)
           {
              if(shield_obj == noone)
              {
                 shield_obj = instance_create(x, y, obj_player_bubble_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_bubble, global.sfx_volume, 1, 0, 0);                 
              }
           }           
           if(shield == SHIELD_ELECTRICITY)
           {
              if(shield_obj = noone)
              {
                 shield_obj = instance_create(x, y, obj_player_electricity_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_electricity, global.sfx_volume, 1, 0, 0);                     
              }
           }
           if(shield == SHIELD_WIND)
           {
              if(shield_obj = noone)
              {
                 shield_obj = instance_create(x, y, obj_player_wind_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_electricity, global.sfx_volume, 1, 0, 0);                     
              }
           }           
    }
    
    if(debug_mode)
    {
       var dbgX, dbgY;
       dbgX = floor(x);
       dbgY = floor(y);
       
       draw_sprite(MASK_MAIN, 0, dbgX, dbgY);
       draw_sprite(MASK_BIG,  0, dbgX - dcos(angle) * 11, dbgY + dsin(angle) * 11);  
       draw_sprite(MASK_BIG,  0, dbgX + dcos(angle) * 11, dbgY - dsin(angle) * 11);   
       draw_sprite(MASK_MID,  0, dbgX - dcos(angle) * 11, dbgY + dsin(angle) * 11);  
       draw_sprite(MASK_MID,  0, dbgX + dcos(angle) * 11, dbgY - dsin(angle) * 11);    
       draw_sprite(MASK_MID,  0, dbgX - dsin(angle) * 11, dbgY - dcos(angle) * 11);  
       draw_sprite(MASK_MID,  0, dbgX + dsin(angle) * 11, dbgY + dcos(angle) * 11);          
       draw_sprite(MASK_LINES, floor(angle), dbgX, dbgY);        
        
       // Draw Shields:    
          if(shield == SHIELD_FIRE)
          {
             if(shield_obj == noone)
             {
                shield_obj = instance_create(x, y, obj_player_fire_shield);
                shield_obj . handle = id;
                aud_play_sound(shield_get_flame, global.sfx_volume, 1, 0, 0);
             }
          }
          if(shield == SHIELD_BUBBLE)
          {
             if(shield_obj == noone)
             {
                shield_obj = instance_create(x, y, obj_player_bubble_shield);
                shield_obj . handle = id;
                aud_play_sound(shield_get_bubble, global.sfx_volume, 1, 0, 0);                 
             }
          }           
          if(shield == SHIELD_ELECTRICITY)
          {
             if(shield_obj = noone)
             {
                shield_obj = instance_create(x, y, obj_player_electricity_shield);
                shield_obj . handle = id;
                aud_play_sound(shield_get_electricity, global.sfx_volume, 1, 0, 0);                     
             }
          }              
    }

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
