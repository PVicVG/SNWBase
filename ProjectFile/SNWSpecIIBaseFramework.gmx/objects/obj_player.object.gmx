<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_editor_start</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>par_player</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Warp To Exit</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>301</id>
        <kind>0</kind>
        <userelative>-1</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>1</exetype>
        <functionname>action_set_alarm</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>0</kind>
            <string>5</string>
          </argument>
          <argument>
            <kind>4</kind>
            <string>0</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>605</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>0</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Setup Variables</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Variables.
 // Sprites;
    sprite_index = spr_player_mask_main;
    mask_index = sprite_index;
 
 // Init. flag:
    initialized     = false;      // Checks if the player has been initialized.
    
 // Character flag.
    player_index    = global.player_id; // Who do we play as?
    player_type     = IS_PLAYER;        // Is a Player or AI?
    sprite = spr_sonic_idle;
    
 // Horizontal movement:
    x_speed         = 0;        // The current horizontal speed.
    x_speed_top     = 6;        // Horizontal top speed while on flat ground.
    x_speed_max     = 16;       // Fastest the player can move.
    g_speed         = 0;        // Stores the ground speed.
    x_acceleration  = 0.046875; // Horizontal acceleration on ground.
    x_deceleration  = 0.5;      // Horizontal deceleration on ground.
    x_slope_factor  = 0.125;    // Rate at which the player slows down on slopes.
    x_air_accel     = 0.09375;  // Acceleration value in the air.
    x_temp_accel    = 0;        // Stores temporal acceleration value. 
    x_temp_decel    = 0;        // Stores temporal deceleration value.
    x_temp_friction = 0;        // Stores temporal friction value.
    x_limit         = false;    // Limits the horizontal speed.
    x_allow         = 0;        // Allows horizontal movement.

 // Vertical movement:
    y_speed         = 0;        // The current vertical speed.
    y_speed_max     = 16;       // Fastest the player can fall.
    y_acceleration  = 0.21875;  // Force of gravity applied to the player.
    y_accel_common  = 0.21875;  // Store original gravity value in case we change it ingame.
    y_conversion    = 1;        // Speed conversion when landing.
    y_limit         = true;     // Limits the vertical speed.
    y_allow         = 0;        // Allows vertical movement.

 // Samples.
    x_sample        = 13;       // Pixel limit to divide horizontal movement.
    y_sample        = 13;       // Pixel limit to divide vertical movement.
          
 // Terrain:
    ground          = 0;        // Checks if the player has/is grounded.
    angle           = 0;        // Returns the angle of the player.
    angle_round     = 0;        // Returns the angle of the player, rounded.
    angle_relative  = 0;        // Returns the angle, relative to gravity values.
    angle_hold      = 0;        // Used to smoothen angle values.
    collision_layer = 0;        // Returns the layers the player is on.
    floor_mode      = 0;        // Returns the floor mode.
    x_beforepush    = 0;        // X Position before player was pushed (not used)      
    y_beforepush    = 0;        // Y Position before player was pushed (not used)
    platform_check  = 0;        // Checks if the player has landed on platforms.
    platform_frames = 30;       // Used to reset the platform check.
    
 // Flags:
    state           = 1;        // Players current state.
    control_lock    = 0;        // Locks the player's movement.
    input_alarm     = 0;        // Input alarm. (Used for slopes9
    input_alarm_dir = 0;        // Which direction we're locking.
    input_lock_l    = 0;        // Locks left input.
    input_lock_r    = 0;        // Locks right input.
    input_lock_s    = 0;        // locks input after using a horizontal spring.
    launch_lock     = 0;        // Disables horizontal input.
    lock_timer      = 0;        // How long input is locked. Used on springs.
    tunnel_lock     = 0;        // Locks the player when inside a tunnel.
    timer_up        = 0;        // Timer for looking up.
    timer_down      = 0;        // Timer for crouching.
    allow_look      = 1;        // Allow crouching/looking up.
    shield          = 0;        // Players current shield.
    shield_obj      = noone;    // Players shield object.
    shield_state    = 0;        // Players shield state.
    shield_usable   = 0         // Is the shield usable?
    invincibility   = 0;        // Is the player invulnerable to hazards? 0 = No, 1 - After getting Hit, 2 - Invincibility Shield or Super Form.
    invincibility_timer = 0;    // How long invincibility lasts.
    physic_mode     = 0;        // Checks the current physic mode. (0 = Default, 1 = Underwater)
    speedshoe       = 0;        // Are we wearing speed shoes?
    speedshoe_timer = 0;        // How long speed shoes last.
    previous_x      = 0;        // Gets the previous x position.
    previous_y      = 0;        // Gets the previous y position. 
    loop_direction  = 0;        // Keeps track in which direction we're going through a loop. Used for AI.
    harmful         = false;    // Can the player hit stuff
    global.AfterImage = 0;      // Can it create afterimages
    
 // Terrain flags:
    platform_id     = noone;    // Returns the id of the platform we're on.
    swing_id        = noone;    // Returns the id of the swing we're on.
 
 // Underwater:
    drown_timer     = 1800;     // How long it takes (in frames) for the character to drown.
    drown_counter   = noone;    // The number count down above the character while about to drown.
    bubble_timer    = 0;        // How long the character is stuck in the breathing state after touching a bubble.
    breath_timer    = 40;       // Needed for creating bubbles after we drowned.
    has_drowned     = false;    // Checks if the Character has drowned.
    
 // States:
    jump_strength     = -6.5    // Players jump strength.
    jump_release      = -4;     // Minimum strength the player can jump.
    jump_completed    = false;  // Checks if the player has completed his jump.
    jump_lock         = 0;      // Is the jump locked? (Means the direction cannot be altered while jumping)
    
    spindash_strength = 0;      // Current strength of the spindash.
    spindash_pitch    = 0;      // Used to change the spindash sound pitch.
    
    roll_deceleration = 0.125;     // Rolling deceleration.
    roll_friction     = 0.0234375  // Friction while rolling.
    roll_decel_up     = 0.078125;  // Deceleration while rolling up slopes.
    roll_decel_down   = 0.3125;    // Deceleration while rolling down slopes.
    
    skid_direction    = 0;         // Direction you're skiddin towards.
    
    grab_timer        = 0;         // Grab timer, prevents us from grabbing onto something as soon as we try to let go.
    grab_type         = 0;         // Grab type, see the grab scripts for more.
    grab_distance     = 0;         // How far we can travel.
    grab_moving       = 0;         // Checks if we're moving-
    grab_id           = 0;
    grab_x            = 0;
    grab_y            = 0;
    
    push_timer        = 0;         // Used to trigger pushing state.
    push_timer_max    = 3;
    
    death_timer       = -5;       // See death script in the step event.
    
    // Tubes n' Stuff //
    tube_type           = 0;        // Used for correct movement.
    tube_timer          = 0;        // Used for playing the roll sound at the correct time when in a tube.
    tube_mov_x          = 0;        // The x movement for the player in a tube.
    tube_mov_y          = 0;        // The y movement for the player in a tube.
 // Animation / Sprite.
    animation_init();
    
 // Done initializing.
    initialized = true;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Stage Specifics.

// Bonus Stage
mynumber = -1;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character specific.

 // Sonic:
    allow_dropdash = true;                   // If true, we allow the player to use the dropdash.
    dropdash_flag  = 0;                      // Returns the dropdash flag. (0 = Null, 1 = Charging, 2 = Ready)
    dropdash_timer = 20;                     // Frames it takes to charge dropdash.
    dropdash_speed = 0;                      // Speed of the dropdash.
    kick_timer = 30;                         // Sonic's Kick.
    
 // Tails: 
    tails_flight_timer    = 0;               // How long we've been flying.
    tails_flight_duration = 480;             // How long we can fly.
    
    tails_tail_sprite     = noone;           // Sprite for Tails tail.
    tails_tail_frame      = 0;               // Current tail frame.
    tails_tail_speed      = 0;               // Animation speed for the tail. 
    tails_tail_x          = 0;               // X Position for the tail.
    tails_tail_y          = 0;               // Y Position for the tail.
    tails_tail_angle      = 1;               // Angle of the tail. 
    tails_tail_direction  = 1;               // Direction of the tail.
    
 // Knuckles:
    glide_top_speed    = 24;                 // Fastest Knuckles can move horizontally while gliding.
    glide_gravity      = 0.125;              // The gravity used while gliding.
    glide_crouch_timer = 25;                 // How long knuckles stays in his crouched state (after a drop)
    glide_turn_s       = 0;                  // Special variable for turning knuckles sprite.
    glide_turn_a       = 0;                  // ^^ 
    climb_ox           = 0;                  // Position that returns the x position when grabbing. If it increases or decreases, we stop climbing.
    climb_speed        = 1;                  // How fast Knuckles can climb up a wall.
    climb_frame_timer  = 6;                  // Advances the climbing frame when it reaches 0.
    is_ledge_grabbing  = 0;                  // Returns if we're ledge climbing.     
     
 // Fang
    ground_timer = -1;      // Check time in the ground for bouncing
    triggered_bounce = false;
    bounce_air_x_speed = 0;     // XSpeed in the air
    bounce_air_y_speed = 0;     // YSpeed in the air
    
 // Modern
    homing_target       = noone;             // Keeps track of the target object.
    homing_mode         = 0;                 // Set the homing mode. (0 = Normal, 2 = Utopia like) (Utopia like = Sonic doesn't come to a full stop after homing into a badnik or spring. Disabled for Monitors.)
    homing_speed        = 12;                // The speed at which Sonic should move towards a homing target.
    homing_distance     = 128;               // The max. distance to find a homing target.
    homing_target_id[0] = obj_monitor; 
    homing_target_id[1] = par_enemy;
    homing_target_id[2] = par_spring;
    boosting       = false;
    boost_amount   = 120;
    boost_startspeed = 11;
    
 // Eggrobo
    dash_timer = -1;
    can_dash = true;
    
 // Shadow
    shadow_dash_x_speed = 0;
    shadow_dash_y_speed = 0;
    shadow_dash_timer = -1;
    shadow_dashes_left = 3;
    
 // Amy:
    hammer_glide_timer = 80;
    common_glide_timer = hammer_glide_timer;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Inputs keys.
 
    input_up               = false;
    input_down             = false;
    input_right            = false;
    input_left             = false;
    input_action           = false;
    input_special          = false;
    
    input_up_pressed       = false;
    input_down_pressed     = false;
    input_right_pressed    = false;
    input_left_pressed     = false;
    input_action_pressed   = false;
    input_special_pressed  = false;    
    
    input_up_released      = false;
    input_down_released    = false;
    input_right_released   = false;
    input_left_released    = false;
    input_action_released  = false;
    input_special_released = false;    

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Camera.

    camera = instance_create(x, y, obj_camera);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Checkpoint respawn.
 
    if(global.checkpoint_x != -1)
    {
       x                = global.checkpoint_x;
       y                = global.checkpoint_y;
       global.game_time = global.checkpoint_t;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Warp to Exits
if global.exit_id != 0
{
    // Warp.
    x = global.exit_id_x[global.exit_id];
    y = global.exit_id_y[global.exit_id];
    obj_camera.cam_x = global.exit_id_x[global.exit_id];
    obj_camera.cam_y = global.exit_id_y[global.exit_id];
    
    // Reset
    global.exit_id = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Animations.

 // Exit if not initialized or death.
    if(initialized = false) exit;
     
 // Setup core system:
    animation_core();
    
 // Apply correct tail parts. 
    if(player_index == CHAR_TAILS)
    {
       animation_tail_setup();
    }
        
 // Apply Animations
    animations_apply()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite rotation.
 // This is used for rotating the players sprite.
 
 // Exit if not initialized, death or hurt.
    if(initialized = false || state = STATE_DEATH || state == STATE_HURT) exit;
 
 // Change animation angle values:
    if(ground)
    {
       if(player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_solid_no_angle) || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_platform_no_angle)
       || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer0_no_angle) || player_collision_check(COL_BOTTOM_OBJECT, MASK_MAIN, x, y, angle, par_layer1_no_angle))
       {       
          animation_angle_mod = 0;
       }
       else
       {
          var _angMod;
          _angMod = animation_angle_mod;
             
          if(angle &gt;= 0 &amp;&amp; angle &lt;= 180)
          {
             if(angle &lt; 36)
             {
                _angMod = 0;
             }
                else
             {
                _angMod = angle;
             }
          }
          if(angle &gt;= 180 &amp;&amp; angle &lt;= 360)
          {
             if(angle &gt; 360-36)
             {
                _angMod = 0;
             }
             else
             {
                _angMod = angle;
             }
          }
          if(abs(angle_difference(animation_angle_mod, _angMod))&lt;45)
          {
             animation_angle_mod = rotate_towards(_angMod, animation_angle_mod, max(4, abs(x_speed)));
          }
          else
          {
             animation_angle_mod = _angMod;
          }
       } 
    }
    else
    {
       animation_angle_mod = rotate_towards(0, animation_angle_mod, 4)
    }
 
 // Rotate:   
    if(global.angle_mode == 0)
    { 
       animation_angle  = round(animation_angle_mod/45)*45;
       tails_tail_angle = round(animation_angle_mod/45)*45;
    }
    else
    {
       animation_angle  = animation_angle_mod;
       tails_tail_angle = animation_angle_mod;     
    } 
    
 // Set angle to zero and exit if we're not using a animation that can be rotated.
    if(animation == "idle" || animation == "idle bored" || animation == "lookup" || animation == "crouch" || animation == "spindash" || animation == "roll" || animation == "push" || animation == "hurt" 
    || animation == "balance" || animation == "balance 2" || animation == "fly" || animation == "swim" || animation == "fly exhausted" || animation == "swim exhausted" || animation == "glide"
    || animation == "glide drop" || animation == "slide" || animation == "ledge climb" || animation == "climb" || animation == "shoot" || animation == "bounce_jump" || animation == "bounce_fall"
    || animation == "bounce_land" || animation == "jump" || animation == "fall" || animation == "hurt" || animation == "death") 
    {
       animation_angle = 0;
    }
    
 // Set the Angle of Miles tail.
    if((state = STATE_JUMP || state = STATE_ROLL || animation = "roll"))
    {
        if(ground == false)
        {
           tails_tail_angle = point_direction(xprevious, yprevious, x, y);
           if(tails_tail_direction != 1)
           {
              tails_tail_direction = 1;
           }
        }
    }     
 
 

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Keep within boundaries

    if(x &lt;= (camera.limit_left+sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &lt; 0.0)
    {
       x_speed   = 0;
       x         = (camera.limit_left+sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation = "idle";
       }
    }
    else
    if(x &gt;= (camera.limit_right-sprite_get_width(MASK_MAIN)/2) &amp;&amp; x_speed &gt; 0.0)
    {
       x_speed   = 0;
       x         = (camera.limit_right-sprite_get_width(MASK_MAIN)/2);
       if(ground)
       {
          animation = "idle";
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platform reset.
 // In order to prevent the player from bouncing off or loosing collision on platform, wait at least 30 frames before reseting the check.
    
    if((ground == false || place_meeting(x, y, par_platform) == false) &amp;&amp; platform_check == 1)
    {
       if(platform_frames &gt; 0)
       {
          platform_frames -= 1;
       }
       else if(platform_frames &lt;= 0)
       {
               platform_check  = 0;
               platform_frames = 30;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Water splash.

    if(global.water_position != -1)
    {
       if ((abs(y_speed) &gt;= 0)
       &amp;&amp; ((y &gt; global.water_position &amp;&amp; previous_y &lt; global.water_position)
       ^^  (y &lt; global.water_position &amp;&amp; previous_y &gt; global.water_position)))
       {
           dummy_effect_create(spr_water_splash, 0.25, x, global.water_position-8, -999996, 0);
           aud_play_sound(general_water_splash, global.sfx_volume, 1, 0, 1);
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Effects

// Afterimage
if ((abs(x_speed) &gt;= 11 or speedshoe != 0 or state == STATE_HOMING or state == STATE_DASH or state == STATE_KICK or state == STATE_HAMMER_DROP) or 
   (animation == "roll" &amp;&amp; !ground &amp;&amp; !shield_usable &amp;&amp; player_index = CHAR_MODERN))
   &amp;&amp; (global.AfterImage = 0)
   &amp;&amp; (visible)
    {
        global.AfterImage = 10;
        instance_create(x,y,objPlayerAfterImage);
    }

if global.AfterImage &gt; 0
    global.AfterImage -= 1;
    
//Trail
    if (player_index == CHAR_MODERN or player_index == CHAR_EGGROBO)
    {
        update_trail(
            floor(x)+cos(degtorad(angle+90))+cos(degtorad(angle))*x_speed,
            floor(y)-sin(degtorad(angle+90))+y_speed-sin(degtorad(angle))*x_speed,
            (state == STATE_HOMING || animation == "roll" || boosting || 
            state == STATE_STOMP || state == STATE_DASH || state == STATE_HAMMER_DROP)
            &amp;&amp; visible
        )
    }
    
    
    if (player_index == CHAR_MIGHTY)
    {
        update_trail(
            floor(x)+cos(degtorad(angle+90))+cos(degtorad(angle))*x_speed,
            floor(y)-sin(degtorad(angle+90))+y_speed-sin(degtorad(angle))*x_speed,
            state == STATE_HAMMER_DROP &amp;&amp; visible
        )
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Receive inputs.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
  
    // Stop Player if Locked
        if !control_lock
        {
            player_inputs()
        }
    
 // Disable input if both left and right is being held.
    if(input_left &amp;&amp; input_right)
    {
       input_left  = false;
       input_right = false;
    }
    
 // Input alarm.
    if(input_alarm)
    {
       if(input_alarm_dir == 1)
       {
          input_right = false;
       }
       if(input_alarm_dir == -1)
       {
          input_left = false;
       }
    }
    
 // Input locks (spring)
    if(input_lock_l)
    {
       input_left = false;
    }
    if(input_lock_r)
    {
       input_right = false;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Modify physics.

 // Previous Positions:
    previous_x = x;
    previous_y = y;
    
 // Switch Physic Modes:
    if(global.water_position != -1)
    {
       if(y &lt; global.water_position)
       {
          if(physic_mode != 0)
          {
             physic_mode = 0
          }
       } 
       if(y &gt; global.water_position)
       {
          if(physic_mode != 1)
          {
             physic_mode = 1;
          }   
       }   
    }
     
 // Get/Set physics for each character.
    player_physics()

    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Death.

    if(death_timer == -1) exit;
    
    if(state == STATE_DEATH)
    {
       // Throw the player into the air.
          if(death_timer == -5)
          {
             angle = 0;
             if(physic_mode == 0)
             {
                y_speed = -7;
             }
             death_timer = 120;
             depth       = -999995;
             
             // Fade out the audio. 
                with(obj_audio)
                {
                     fadeout_flag = 1;
                }
                
             // Decrease lives.
                global.player_lives -= 1;
                if(global.player_lives &lt; 0)
                {
                   global.player_lives = 0;
                }
                
             // Play death/drown sound.
                if(has_drowned == false)
                {
                   aud_play_sound(player_die, global.sfx_volume, 1, 0, 0);
                }
                else
                {
                   aud_play_sound(player_drowned, global.sfx_volume, 1, 0, 0);                
                }
                audio_stop_sound(player_flying);
                audio_stop_sound(player_flying_drop);
                
             // Destroy shields.
                shield = 0;
                with(shield_obj)
                {
                     instance_destroy();
                }
                shield_obj = noone;                
          }
          
       // Set Gravity:
          if(physic_mode == 0){
             y_speed += 0.21875;
          }else{
             y_speed += 0.0625;
          }
          y  += y_speed;          
          
       // Decrease timer.
          if(death_timer &gt; 0)
          {
             death_timer -= 1;
          }
          else if(death_timer == 0)
          {
             death_timer = -1;
             if(global.player_lives &gt; 0)
             {
                instance_create(0, 0, obj_fade_restart);
             }
             else
             {  
                global.previous_room = room;
                instance_create(0, 0, obj_game_over);            
             }
          }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// XP

if (global.xp &gt;= global.level * 100)
{
    global.xp = global.xp - global.level * 100;
    global.level += 1;
}

if keyboard_check(vk_delete)
{
global.xp ++;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Die from Heights.

    if(global.death_height == -1)
    {
       if(y &gt;= room_height &amp;&amp; state != STATE_DEATH)
       {
          state = STATE_DEATH;
       }
    }
    else
    {
       if(y &gt;= global.death_height &amp;&amp; state != STATE_DEATH)
       {
          state = STATE_DEATH;
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collision Detecting and Movement.

player_handles()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Harmfulness
player_set_harmfullness()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Horizontal movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;

 // Input alarm. Ignores left or right input if above zero.
    if(input_alarm)
    {
       input_alarm -= 1;
    }else{
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
    if(input_alarm &amp;&amp; angle == 0)
    {
       input_alarm     = 0;
       input_alarm_dir = 0;
    }
    
 // Store Accel/Decel changes.
    if(ground)
    {
       x_temp_accel    = x_acceleration;
       x_temp_decel    = x_deceleration;
       x_temp_friction = x_temp_accel;
    }else{
       x_temp_accel    = x_acceleration * 2;
       x_temp_decel    = 0;
       x_temp_friction = 0;
    }
    
 // Exit if we're not allowing x movement:
    if(x_allow == false) exit;
    
 // Decelerate on slopes:
    if(state != STATE_SLIDE)
    {
       if(state = STATE_ROLL &amp;&amp; ground)
       {
          // Rolling up a slope:
             if((angle_relative &lt; 180 &amp;&amp; x_speed &gt; 0) || (angle_relative &gt; 180 &amp;&amp; x_speed &lt; 0))
             {
                x_speed -= dsin(angle_relative)*roll_decel_up;
             }else{
                x_speed -= dsin(angle_relative)*roll_decel_down;
             }
       }else{
          // Decelerate normally:
             if(ground &amp;&amp; ((angle_relative &gt; 35 &amp;&amp; angle_relative &lt; 330) || round(x_speed) != 0 || input_alarm != 0))
             {
                x_speed -= dsin(angle_relative) * 0.125;
             }
       }
    }
    
 // Continue if in one of the following states.
    if((state == STATE_DEFAULT || state = STATE_FANG_BOUNCE || state = STATE_HAMMER_DROP
    || state = STATE_HAMMER_BOUNCE || state = STATE_WOBBLE || state = STATE_HAMMER_PUNCH
    || state = STATE_JUMP_DOUBLE || (state = STATE_JUMP &amp;&amp; !jump_lock) || state = STATE_HAMMER_GLIDE
    || state == STATE_SKID || state == STATE_FLY || state == STATE_FLYDROP 
    || state == STATE_SPRING || state == STATE_CORKSCREW || state == STATE_CORKSCREW_ROLL 
    || state == STATE_GLIDE_DROP) &amp;&amp; (state != STATE_GLIDE &amp;&amp; state != STATE_SLIDE 
    &amp;&amp; state != STATE_CLIMB))
    {
       // Handle Accel/Decel:
          if((ground &amp;&amp; input_alarm == 0))
          {
             if(input_left == true)
             {
                if(x_speed &gt; 0)
                {
                   x_speed -= x_temp_decel;
                }else{
                   if(x_speed &gt; -x_speed_top)
                   {
                      x_speed -= x_temp_accel;
                   }
                }
             }else if(input_right == true)
             {
                if(x_speed &lt; 0)
                {
                   x_speed += x_temp_decel;
                }else{
                   if(x_speed &lt; x_speed_top)
                   {
                      x_speed += x_temp_accel;
                   }
                }                
             }else{
                x_speed -= min(abs(x_speed), x_temp_friction)*sign(x_speed);
             }
          }else{
             // Air Cap:
                if(y_speed &gt; 16)
                {
                   y_speed = 16;
                }
                
             // Air acceleration:
                if(input_right)
                {
                   if(state == STATE_FLY || state == STATE_FLYDROP || state == STATE_GLIDE_DROP)
                   {
                      if(x_speed &lt; 0)
                      {
                         x_speed += x_temp_accel;
                      }
                      else if(x_speed &lt; x_speed_top)
                      {
                              x_speed += x_air_accel;
                      }                      
                   }
                   else
                   {
                      x_speed += x_air_accel;
                   }
                }
                
                if(input_left)
                {
                   if(state == STATE_FLY || state == STATE_FLYDROP || state == STATE_GLIDE_DROP)
                   {
                      if(x_speed &gt; 0)
                      {
                         x_speed -= x_temp_accel;
                      }
                      else if(x_speed &gt; -x_speed_top)
                      {
                              x_speed -= x_air_accel;
                      }                      
                   }
                   else
                   {
                      x_speed -= x_air_accel;
                   }
                }
          }
    }
   
 // Fall if there's not enough speed:
    if(angle_relative &gt; 45 &amp;&amp; angle_relative &lt; 315 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 2.5 &amp;&amp; tunnel_lock = 0)
    {
       if(angle_relative &gt;= 90 &amp;&amp; angle_relative &lt;= 270)
       {
          y_speed = -dsin(angle_relative)*x_speed;
          x_speed =  dcos(angle_relative)*x_speed;
          ground  = false;
       }else{
          input_alarm = 40;
          if(input_alarm_dir == 0)
          {
             input_alarm_dir = animation_direction;
          }
       }
    }
     
 // Get new angle:
    if(ground &amp;&amp; player_collision_check(COL_LEFT_EDGE, x, y, angle, -1, -1)
              &amp;&amp; player_collision_check(COL_RIGHT_EDGE, x, y, angle, -1, -1))
    {
       player_angle(player_calculate_angle(x, y, angle));
    }else{
       player_angle(0);
    }
   
 // Full stop when colliding with a wall.
    if((x_speed &gt; 0 &amp;&amp; player_collision_check(COL_RIGHT, MASK_BIG, x, y, angle, -1)) || (x_speed &lt; 0 &amp;&amp; player_collision_check(COL_LEFT, MASK_BIG, x, y, angle, -1))){
        x_speed = 0;
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Vertical movement.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Exit if we're not allowing x movement:
    if(y_allow == false) exit;
            
 //  Return to a normal state:
     if(ground)
     {
        y_speed = 0;
        if(state = STATE_JUMP || state == STATE_SPRING)
        {
           if(state = STATE_HURT)
           {
              x_speed = 0;
           }
           state = STATE_DEFAULT;
        }
        
        // Check if the player is really grounded:
           if(player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == false)
           {
              ground = false;
              player_angle(0);
           }
     }
     
 // Otherwise, add gravity:
    if(!ground)
    {
           // Gravity:           
              if(state != STATE_CORKSCREW &amp;&amp; state != STATE_CORKSCREW_ROLL)
              {
                 y_speed += y_acceleration;
              }
              
           // Check if we landed:
              if(y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_BIG, x, y, angle, -1) == true)
              {
                 // We grounded:
                    ground = true;
                    
                 // Return to normal state:
                    if(state = STATE_JUMP || state == STATE_FLY || state == STATE_FLYDROP || state = STATE_HURT)
                    {
                       if(state = STATE_HURT)
                       {
                          x_speed = 0;
                       }
                       state = STATE_DEFAULT;
                    }
              }
              
           // Check if we're in the air but collide with a ceiling.
              if(y_speed &lt; 0 &amp;&amp; player_collision_check(COL_TOP, MASK_BIG, x, y, angle, -1) == true)
              {
                 y_speed = 0;
                 if(state = STATE_DEFAULT &amp;&amp; x_speed == 0 &amp;&amp; y_speed == 0)
                 { 
                    state = STATE_ROLL;
                 }
              }
    }
     
 // Reset horizontal speed after getting hurt.
    if(y_speed &gt;= 0 &amp;&amp; player_collision_check(COL_BOTTOM, MASK_MAIN, x, y, angle, -1) == true)
    {
       if(state == STATE_HURT)
       {
          x_speed = 0;
          state   = STATE_DEFAULT;
       }
    }

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Air drag and floor mode.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Air Drag:
    if(ground == false &amp;&amp; state != STATE_HURT)
    {
       if(y_speed &lt; 0 &amp;&amp; y_speed &gt;= -4)
       {
          x_speed -= ((x_speed / 0.125) / 256);
       }
    }
    
 // Return the floor mode:
    floor_mode = round(angle/90) mod 4;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Input disabling.

 // Exit if not initialized, death or hurt.
    if(initialized = false || state = STATE_DEATH || state == STATE_HURT) exit;
    
 // Enable input after jumping:
    if(input_lock_s &amp;&amp; !jump_lock &amp;&amp; state == STATE_JUMP)
    {
       lock_timer      = 0;
       input_alarm_dir = 0;
    }
    
 // Disable direction lock when the angle is equal to 0.
    if(input_alarm_dir != 0 &amp;&amp; angle == 0)
    {
       input_alarm_dir = 0;
    }
    
 // Disable spring lock:
    if(lock_timer &lt; 1 &amp;&amp; input_lock_s == true)
    {
       input_lock_s = 0;
       input_lock_l = 0;
       input_lock_r = 0;
    }
    
 // Enable locks:
    if(input_lock_s &amp;&amp; x_speed &gt; 0)
    {
       input_lock_l = 1;
       input_right  = 1;
    }
    else if(input_lock_s &amp;&amp; x_speed &lt; 0)
    {
            input_lock_r = 1;
            input_left   = 1;
    }
    
 // Decrease timers.
    if(lock_timer)
    {
       lock_timer -= 1;
    }if(lock_timer &lt; 0) { lock_timer = 0 };


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// States.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    if(x_allow == false &amp;&amp; y_allow == false) exit;
    
    player_states()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Invincibility/Speedup Timers.

 // Exit if not initialized or death.
    if(initialized = false || state = STATE_DEATH) exit;
    
 // Decrease invincibility timer.
    if(invincibility_timer &gt; -1)
    { 
       invincibility_timer -= 1;
       if(invincibility_timer == 0)
       {
          invincibility       =  0;
          invincibility_timer = -1;
          if(animation_alpha &lt; 1)
          {
             animation_alpha = 1;
          }
       }
    } 

 // Stop jingles.
    if(audio_is_playing(jingle_invincibility) &amp;&amp; invincibility == 0)
    { 
       audio_stop_sound(jingle_invincibility);
    }
    
 // Don't show shields.
    if(shield != 0 &amp;&amp; invincibility &gt; 1)
    { 
       if(shield_obj != noone)
       {
          shield_obj.visible = false;
       }
    }
    else
    {
       if(shield_obj != noone)
       {
          shield_obj.visible = true;
       }     
    }
    
 // Start timer once we land after being hit.
    if(invincibility == 1 &amp;&amp; invincibility_timer == -1)
    {
       if(ground)
       { 
          invincibility_timer = 120;
       }
    }
 
 // Sparkles.
    if(invincibility &gt; 1)
    {
       repeat(1)
       {
              instance_create(x, y, obj_invincibility_sparkle)
       }
    }
    
 // Speedshoe timer.
    if(speedshoe_timer &gt; 0)
    {  
       speedshoe_timer -= 1;
    }
    else
    {
       if(speedshoe_timer == 0)
       {
          if(speedshoe == true)
          {
             speedshoe = false;
          }
       }
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Underwater handling.

 // Don't run in certain cases:
    if(state != STATE_DEATH &amp;&amp; !instance_exists(obj_results))
    {
       if(physic_mode == 1)
       {
          // Destroy the countdown if we have a bubble shield and keep the drown timer fixed.
             if(shield == SHIELD_BUBBLE)
             {
                drown_timer = 1800;
                if(instance_exists(drown_counter))
                {
                   with(drown_counter)
                   {
                        instance_destroy();
                   }
                   drown_counter = noone;     
                }
                exit;
             }
             
          // Decrease our drown timer.
             if(drown_timer &gt; 0)
             {
                drown_timer -= 1;
             }
             
          // Start the drowning theme.
             if(drown_timer == 650)
             {
               if(audio_is_playing(jingle_drown) == false)
               {
                  aud_play_sound(jingle_drown, global.sfx_volume, 1, 0, 1);
               }
               if(instance_exists(obj_water_alarm) == false)
               {
                  drown_counter = instance_create(x, y-32, obj_water_alarm);
                  drown_counter . parent = id;
               }
             }
             
          // Kill the player.
             if(drown_timer == 0)
             {
                drown_timer = 1800;
                state       = STATE_DEATH;
                has_drowned = true;
                if(audio_is_playing(jingle_drown))
                {
                   audio_stop_sound(jingle_drown);
                }
             }
             
          // Bubble state.
             if(state == STATE_BREATH &amp;&amp; !ground)
             {
                if(bubble_timer &lt; 1)
                {
                   x_speed = 0;
                   y_speed = 0;
                }
                if(input_left || input_right)
                {
                   x_speed += animation_direction*.025;
                }
                if(bubble_timer &lt; 20)
                {
                   bubble_timer += 1;
                }
                else
                {
                   bubble_timer = 0;
                   animation    = "walk";
                   state        = STATE_DEFAULT;
                }
                drown_timer = 1800;
                if(instance_exists(drown_counter))
                {
                   with(drown_counter)
                   {
                        instance_destroy();
                   }
                   drown_counter = noone;                        
                }
                if(audio_is_playing(jingle_drown))
                {
                   audio_stop_sound(jingle_drown);
                }
             }
             else if(state == STATE_BREATH &amp;&amp; ground)
             {
                     state       = STATE_DEFAULT;
                     drown_timer = 1800;
                     if(instance_exists(drown_counter))
                     {
                        with(drown_counter)
                        {
                             instance_destroy();
                        }
                        drown_counter = noone;                             
                     }                
                     if(audio_is_playing(jingle_drown))
                     {
                        audio_stop_sound(jingle_drown);
                     }                         
             }
                                   
          // Remove bubble timer.
             if(state != STATE_BREATH)
             {
                bubble_timer = 0;
             }           
             
          // Alarm sounds.
             if(drown_timer mod 400 == 0)
             {
                if(audio_is_playing(jingle_drown) == false)
                {
                   aud_play_sound(general_alarm_count, global.sfx_volume, 1, 0, 0);
                }                
             }
             
          // Air bubbles. 
             if(drown_timer mod 78 == 0 &amp;&amp; drown_timer &gt; 600)
             {
                bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_air_bubble);
                bubble . bubble_index = choose(0, 1, 2, 1, 3);
             }
       }
    }
    
 // Above water, reset timers and destroy misc. stuff.
    if(physic_mode == 0)
    {
       drown_timer = 1800;
       if(instance_exists(drown_counter))
       {
          with(drown_counter)
          {
                instance_destroy();
          }
          drown_counter = noone;
       }
       if(audio_is_playing(jingle_drown))
       {
          audio_stop_sound(jingle_drown);
       }  
    }
    
 // Drowning bubbles.
    if(state == STATE_DEATH &amp;&amp; has_drowned == true)
    {
       if(breath_timer != 0)
       {  
          breath_timer -= 1;
          if(random(4) &gt;= 2)
          {
             bubble = instance_create(x+irandom_range(-7, 8), y-6, obj_water_air_bubble);
             bubble . bubble_index = choose(0, 1, 2, 1, 3);
             bubble . depth        = -999996;             
          }
       }
    }



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="5">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.custom_palette --;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.custom_palette += 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Bounce from Boss
    objHandle = player_collision_check(COL_MAIN_OBJECT, x, y, par_boss, -1, -1);
    
    if (objHandle != noone)
    {
        if (harmful)
        {
              angle_to_boss = degtorad(round(wrap_angle(point_direction(x, y, par_boss.x, par_boss.y)-90)/22.5)*24);
              x_speed = sin(wrap_angle(angle_to_boss))*5;
              y_speed = cos(wrap_angle(angle_to_boss))*5;   
              ground  = false;
                    
                    if harmful
                    {
                        if ground
                        {
                            state = STATE_ROLL;
                        }
                        else
                        {
                            state = STATE_JUMP;
                        }
                    } 
        }
        else
        {
              if(state != STATE_HURT &amp;&amp; state != STATE_DEATH &amp;&amp; player_type == IS_PLAYER){
                    player_state_hurt(objHandle, false);
               }
        }
    }
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw Playable.

    if not(initialized) exit;

        // Set Pallete.
        apply_player_pal()
        
        // Draw Trail
         if (player_index == CHAR_MODERN or player_index == CHAR_EGGROBO or player_index == CHAR_MIGHTY) &amp;&amp; (state != STATE_DEATH)
         {
             draw_set_color(EffColor);
             draw_trail(sprTrail2, 20, true);
         }
         
        // Draw Player:
           if(invincibility == 1 &amp;&amp; invincibility_timer &gt; 0)
           {
             if((global.object_time div 60) mod 3)
             {
                 if(tails_tail_sprite != noone)
                 {
                    draw_sprite_ext(tails_tail_sprite, floor(tails_tail_frame), floor(x+tails_tail_x), floor(y+tails_tail_y), tails_tail_direction, 1, tails_tail_angle, animation_color, animation_alpha); 
                 }             
                 draw_sprite_ext(sprite, floor(animation_frame), floor(x), floor(y), animation_direction, 1, animation_angle, animation_color, animation_alpha);                     
             }
           }
           else
           {
              if(tails_tail_sprite != noone)
              {
                 draw_sprite_ext(tails_tail_sprite, floor(tails_tail_frame), floor(x+tails_tail_x), floor(y+tails_tail_y), tails_tail_direction, 1, tails_tail_angle, animation_color, animation_alpha); 
              }
              draw_sprite_ext(sprite, floor(animation_frame), floor(x), floor(y), animation_direction, 1, animation_angle, animation_color, animation_alpha);    
           }
           
        // Draw Jump Orbs
                if (animation == "roll" &amp;&amp; !ground &amp;&amp; shield_usable &amp;&amp; player_index = CHAR_MODERN &amp;&amp; state != STATE_HOMING)
                {
                    draw_set_blend_mode(bm_add);
                    draw_sprite_ext(spr_modern_jump_orb, floor(animation_frame), floor(x), floor(y) - 3, animation_direction, 1, global.object_time * animation_direction, animation_color, 0.8);              
                    draw_set_blend_mode(bm_normal);  
                 }       
                 
        // Draw Spindash dust:
         if(state == STATE_SPINDASH)
           {
              draw_sprite_ext(spr_spindash_dust, current_time div 40, floor(x-animation_direction*1), floor(y+1), animation_direction, 1, 0, c_white, 1);  
           }
        
        // Draw Shields:    
           if(shield == SHIELD_FIRE)
           {
              if(shield_obj == noone)
              {
                 shield_obj = instance_create(x, y, obj_player_fire_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_flame, global.sfx_volume, 1, 0, 0);
              }
           }
           if(shield == SHIELD_BUBBLE)
           {
              if(shield_obj == noone)
              {
                 shield_obj = instance_create(x, y, obj_player_bubble_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_bubble, global.sfx_volume, 1, 0, 0);                 
              }
           }           
           if(shield == SHIELD_ELECTRICITY)
           {
              if(shield_obj = noone)
              {
                 shield_obj = instance_create(x, y, obj_player_electricity_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_get_electricity, global.sfx_volume, 1, 0, 0);                     
              }
           }
           if(shield == SHIELD_WIND)
           {
              if(shield_obj = noone)
              {
                 shield_obj = instance_create(x, y, obj_player_wind_shield);
                 shield_obj . handle = id;
                 aud_play_sound(shield_wind, global.sfx_volume, 1, 0, 0);                     
              }
           } 
       // ReSet Palette
        pal_swap_reset() 
              
       // Draw Circular Bar
        if state == STATE_FLY or state == STATE_FLYDROP
        {
            draw_circular_bar( floor(x) - 18, floor(y) + 16, tails_flight_duration - tails_flight_timer, tails_flight_duration, c_lime, 6, 0.95, 3, true, c_gray, 0.8)
        }    
        
        if input_special &amp;&amp; player_index == CHAR_MODERN
        {
            draw_circular_bar( floor(x) + 18, floor(y) - 23, boost_amount, 120, make_color_rgb(0, 255, 255), 6, 0.9, 3, true, c_gray, 0.75)
        }      

        
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
